## 第12章 类和动态内存分配

### 概述

- 对类成员使用动态内存分配
- 隐式和显式复制构造函数
- 隐式和显式重载赋值运算符
- 在构造函数中使用new所必须完成的工作
- 使用静态类成员
- 将定位new运算符用于对象
- 使用指向对象的指针
- 实现队列抽象数据类型

介绍如何对类使用new和delete以及如何处理由于使用动态内存引起的一些微妙的问题。

### 12.1 动态内存和类

静态类成员：无论创建了多少对象，程序之创建一个静态类变量副本，**类的所有对象共享同一个静态成员**

`strngbad.h` 中 `StringBad` 类静态成员 `num_strings` 
```c
class StringBad
{
private:
    ...
    char * str;
    static int num_strings;
    ...
}
```

静态成员变量：
- 类的所有对象共享一个静态成员
- 不能在类声明中初始化，static const int 和 enum 枚举类型除外
- 在类函数实现的文件中初始化

不能对字符指针直接赋值，字符串保存在堆中，对象中仅保存了地址
```c
str = s;    // 不能这样直接赋值
```

在 `vegnews.cpp` 中 `callme2(headline2);` 将对象作为函数参数**按值传递**导致析构函数被调用，导致原始 `headline2` 被修改。

**对象作为参数按值传递为什么会调用析构函数？为什么实参中的内容会被修改？**

因为对象按值传递时，编译器自动生成的**复制构造函数**进行了指针的简单拷贝，像 `str=s` 一样，这样当你将对象传递给函数时确实会有一个拷贝，但是这个拷贝会有一个指针的拷贝，所以两个对象中的 str 指向的内存一样，在退出函数时，析构销毁了函数中对象中的指针，但不幸的是这样实参对象 `str` 指向的内容也被销毁。

当使用一个对象来初始化另一个对象的时候，编译器将自动生成上述构造函数（复制构造函数），创建一个对象的副本。
```c
StringBad sailor = sports;
// 等效于
StringBad sailor = StringBad(sports);
// 相对应的构造函数应该是
StringBad(const StringBad &);
```

自动生成的复制构造函数不知道需要更新静态成员变量，以及包括隐式赋值运算符的问题造成了 `StringBad` 类测试文件 `vegnews.cpp` 中的问题

如果没有手动定义，C++ 自动提供以下成员函数：
- 默认构造函数，如果没有定义构造函数
- 默认析构函数
- 复制构造函数
- 赋值运算符
- 地址运算符
- 移动构造函数（C++11）
- 移动赋值运算符（C++11)

#### 复制构造函数

 <u>**何时调用复制构造函数？**</u>

新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。

以下四种情况都将调用拷贝构造函数：
```c
StringBad ditto(motto);
StringBad metoo = motto;
StringBad also = StringBad(motto);
StringBad * pStringBad = new StringBad(motto)
```

- 中间2种声明可能会使用复制构造函数直接创建metoo和also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also，这取决于具体的实现。最后一种声明使用motoo初始化一个匿名对象，并将新对象的地址赋给pstring指针。
- 每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。
- 编译器生成临时对象时，也将使用复制构造函数。例如，将3个Vector对象相加时，编译器可能生成临时的Vector对象来保存中间结果。
- 按值传递和返回对象都将调用复制构造函数

**默认隐式复制构造函数逐个按值复制非静态成员（也称浅复制），复制的是成员的值。** 例如，对于指针成员变量，复制的是指针的值，而不是指针指向的值，那就意味着在浅复制后，原始对象和复制对象中的指针变量指向同一块内存，那么在复制对象调用析构函数释放内存后，对于原始对象来说，指针指向了一块不合法的地址。

<u>**定义一个显示复制构造函数来解决默认构造函数浅复制带来的问题**</u>

**当类成员有使用new初始化，指向数据的指针的情况时**，一定要在显示复制构造函数中手动进行深度复制。

```c
StringBad::StringBad(const StringBad * st)
{
    num_strings++;
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    ...
}
```

