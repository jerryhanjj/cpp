### 概述
- 运算符重载
- 友元函数
- 重载<<运算符
- 状态成员
- 使用rand()生成随机值
- 类的自动转换和强制类型转换
- 类转换函数

### 11.1 运算符重载

重载后的运算符通过操作数的数目和类型来决定使用哪种操作


注意：
> 不要返回指向局部变量或临时对象的引用。函数执行完毕后局部变量和临时对象消失，引用将指向不存在的数据


一下两种情况等价
```c
total = coding.operator+(fixing);

total = coding + fixing;
```

因为“+”号是从左向右结合的运算符，对于 `mytime1.h` 中的 `Time operator+(const Time & t) const;`
```c++
t4 = t1 + t2 + t3;
// 等价于
t4 = t1.operator+(t2 + t3);
// 更进一步有
t4 = t1.operator+(t2.operator+(t3))
```

#### 运算符重载的限制

运算符可以通过成员函数或者非成员函数来重载，有些只能通过成员函数来重载！

1. 重载后的运算符必须至少有一个操作数是用户定义的类型，防止用户为标准类型重载运算符
2. 使用运算符不能违反原来的句法原则，例如不能将 % 重载成使用一个操作数
3. 不能修改运算符的优先级
4. 不能创建新的运算符
5. 不能重载下面的运算符
   -  sizeof
   - .
   -  .*
   - ::
   - typeid
   - const_cast, dynamic_cast, reinterpret_cast, static_cast
6. **只能通过成员函数来重载的运算符**
   - =
   - ( )
   - [ ]
   - ->

### 11.3 友元

友元有3种：
- 友元函数
- 友元类
- 友元成员函数

通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限，本章只介绍友元函数，友元类和友元成员函数将在15章介绍。

对于在 `mytime2.h` 中的 `Time operator*(double n) const` 函数，被限制了使用方式
```c
adjusted = total * 1.5; // adjusted = total.operator(1.5);
// 而不能像下面这样
adjusted = 1.5 * total; // 不能被转换
```

二者从概念上是一样的，但是类的角度来看，1.5 不是 Time 类的对象，无法重载 * 运算符，所以不能出现第二种方式

告知每个人只能使用第一种方式这并不是一种明智的选择，此时可以通过**非成员函数中的友元函数**来解决

对于非成员重载运算符来说，运算符表达式左边的操作数对应于函数的第一个参数，右边的操作数对应于第二个参数
```c
A = 1.5 * B;
A = operator*(1.5, B);
// 原型
Time operator*(double m, const Time &t);
```

#### 创建友元

```c
friend Time operator*(double m, const Time &t);
```

注意：
- 虽然函数在类中声明，但不是成员函数，不能使用成员运算符（.）来调用
- 与成员函数访问权限相同
- 不需要使用 Time:: 类限定符
- 不在定义中使用 friend 关键字

#### 友元函数是否违背数据隐藏原则

- 可以将友元函数看做成员函数的拓展接口
- 只有类声明可以决定哪一个函数是友元，因此私有数据仍被控制访问

通过下面的方式是更好的一种选择，将其声明为友元或者非友元都可以
```c
Time operator*(double m, const Time &t)
{
    return t * m;   // 调用成员函数，调换操作数的顺序
}
```

